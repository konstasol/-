import random
from Binary_Functions import split_binary

"""
1.Συνάρτηση μετάλλαξης για δεκαδικό σύστημα (ακέραια(2) και πραγματική(3) αναπαράσταση
-Δέχεται σαν ορίσματα, μια λίστα πληθυσμού (συνήθως τα άτομα που έχουν προκύψει μετά και το βήμα της αναπαραγωγής),
τον συντελεστή μετάλλαξης, τον τύπο αναπαράστασης (εδώ 1 ή 2), και τον αριθμό των δεκαδικών)
Για κάθε μεταβλητή του κάθε ατόμου, γυρίζει μια ρουλέτα και παράγεται ένας τυχαίος αριθμός από 0-1
Αν ο αριθμός είναι μικρότερος του συντελεστή μετάλλαξης που έχει δώσει ό χρήστης, η μεταβλητή του ατόμου που διατρέχεται
θα υποστεί μετάλλαξη. Παράγεται μια τυχαία μεταβλητή εντός των εκάστοτε ορίων.
Στο τέλος επιστρέφουμε μια λίστα, με τα υπάρχοντα άτομα και τα άτομα που έχουν υποστεί μετάλλαξη. 
Η λίστα αυτή είναι και η  νέα γενιά αφού αυτό είναι το τελευταίο στάδιο κάθε επαναληπτικού κύκλου
του γενετικού αλγόριθμου.

"""


def mutate_population_dekadiko(population, pm, representation, decimals):
    mutated_population = []  # λίστα για το νέο πληθυσμό με τα μεταλλαγμένα άτομα

    for individual in population:  # διατρέχουμε τη λίστα πληθυσμού για κάθε άτομο

        mutated_individual = individual.copy()  # Δημιουργία αντίγραφου του κάθε ατόμου που διατρέχεται
        # αν μεταλλαχθεί θα αλλάξει κατάλληλα, αν όχι θα περάσει αυτούσιο στην τελική λίστα της μεταλλαγμένης γενιάς

        if representation == 2:  # Ακέραια αναπαράσταση

            for j in range(len(individual)):  # διατρέχουμε την εσωτερική λίστα με τις τρεις μεταβλητές

                x = random.random()  # παράγουμε τυχαίο αριθμό
                if x < pm:  # Έλεγχος για την εφαρμογή μετάλλαξης με βάση την πιθανότητα pm

                    # Δημιουργία νέου τυχαίου αριθμού ανάλογα με τη μεταβλητή που διατρέχεται
                    if j == 0:  # αν δοθεί το οκ για μετάλλαξη, και είμαστε στο j=0, θα μεταλλαχθεί το x
                        new_gene = str(random.randint(0, 10))  # δημιουργία μεταλλαγμένου χ εντός ορίων
                    elif j == 1:  # αν δοθεί το οκ για μετάλλαξη, και είμαστε στο j=1, θα μεταλλαχθεί το y
                        new_gene = str(random.randint(0, 20))  # δημιουργία μεταλλαγμένου y εντός ορίων
                    else:  # αν δοθεί το οκ για μετάλλαξη, και είμαστε στο j=2 (τελευταία περίπτωση), θα μεταλλαχθεί
                        # το z
                        new_gene = str(random.randint(0, 30))  # δημιουργία μεταλλαγμένου z εντός ορίων
                    # Αλλαγή της μεταβλητής που μεταλλάχθηκε στην αντίστοιχη θέση του ατόμου
                    mutated_individual[j] = new_gene

        elif representation == 3:  # Πραγματική αναπαράσταση
            for j in range(len(individual)):
                # Έλεγχος για την εφαρμογή μετάλλαξης με βάση την πιθανότητα pm
                x = random.random()
                # όμοια διαδικασία με την ακέραια αναπαράσταση, αλλάζει ο παραγόμενος τυχαίος αριθμός που
                # είναι πραγματικός με όση ακρίβεια δεκαδικών ορίζει ο χρήστης
                if x < pm:

                    # Δημιουργία νέου τυχαίου αριθμού
                    if j == 0:
                        new_gene = str(round(random.uniform(0, 10.0), decimals))

                    elif j == 1:
                        new_gene = str(round(random.uniform(0, 20.0), decimals))

                    else:
                        new_gene = str(round(random.uniform(0, 30), decimals))

                    # Αλλαγή της αντίστοιχης μεταβλητής
                    mutated_individual[j] = new_gene
        mutated_population.append(mutated_individual)  # προσάρτηση κάθε ατόμου, μεταλλαγμένου και μη
        # στη νέα τελική λίστα του μεταλλαγμένου πληθυσμού

    return mutated_population  # Επιστροφή λίστας τελικού πληθυσμού μετά και την εφαρμογή της μετάλλαξης


"""2. Συνάρτηση μετάλλαξης για δυαδική αναπαράσταση (1) -Δέχεται σαν ορίσματα, μια λίστα πληθυσμού (συνήθως τα άτομα 
που έχουν προκύψει μετά και το βήμα της αναπαραγωγής), τον συντελεστή μετάλλαξης, και τον αριθμό των δεκαδικών) Για 
κάθε άτομο και για κάθε δυαδικό του ψηφίο, γυρίζει μια ρουλέτα και παράγεται ένας τυχαίος αριθμός από 0-1 Αν ο 
αριθμός είναι μικρότερος του συντελεστή μετάλλαξης που έχει δώσει ό χρήστης, το binary ψηφίο του ατόμου που 
διατρέχεται θα υποστεί μετάλλαξη και θα γίνει 0 αν ήταν 1 και το αντίστροφο. Παράγεται έτσι ένα τυχαίο binary string. 
Στη συνέχεια με decoding κάνουμε έλεγχο ανά μεταβλητή να δούμε αν είναι εντός ορίων. Αν πρατηρηθεί ότι κάποια 
μετάβλητη πήρε μη νόμιμη τιμή, επαναφέρουμε στην αρχική του μορφή το μεταλλαγμένο κομμάτι που αντιστοιχεί σε αυτή και 
του δίνουμε "καρφωτά" την πιο κοντινή νόμιμη τιμή. Στο τέλος επιστρέφουμε μια λίστα, με τα υπάρχοντα άτομα και τα 
άτομα που έχουν υποστεί μετάλλαξη. Η λίστα αυτή είναι και η  νέα γενιά αφού αυτό είναι το τελευταίο στάδιο κάθε 
επαναληπτικού κύκλου του γενετικού αλγόριθμου."""


def mutate_population_binary(population, pm, decimals):
    mutated_population = []  # λίστα με μεταλλαγμένο πληθυσμό

    for individual in population:  # διατρέχουμε το κάθε άτομο του πληθυσμού που δόθηκε για μετάλλαξη
        mutated_individual = list(individual)  # μετατρέπουμε το binary σε λίστα ψηφίων για ευκολότερο χειρισμό
        # και παράλληλα δημιουργούμε αντίγραφου του κάθε ατόμου που διατρέχεται
        # αν μεταλλαχθεί θα αλλάξει κατάλληλα, αν όχι θα περάσει αυτούσιο στην τελική λίστα της μεταλλαγμένης γενιάς
        # αφού ξαναμετατραπεί σε string

        for j in range(len(individual)):  # διατρέχουμε κάθε δυαδικό ψηφίο
            if random.random() < pm:  # εξετάζουμε αν ο τυχαίο αριθμός είναι μικρότερος από την πιθ.μετάλλαξης
                original_gene = mutated_individual[j]  # αποθηκεύουμε το αρχικό bit ώστε αν
                # βγει εκτός ορίων, να το επαναφέρουμε και να δώσουμε "χειροκίνητα" την πιο κοντινή νόμιμη τιμή
                if mutated_individual[j] == '0':  # αν είναι 0 το μετατρέπουμε σε 1
                    mutated_individual[j] = '1'

                else:
                    mutated_individual[j] = '0'  # αν είναι 1 το μετατρέπουμε σε 0

                # Μετατροπή σε string για να το περάσομε στη συνάρτησή που κάνει decoding ώστε να ελέγχουμε για μη
                # νόμιμες τιμές
                temp = ''.join(mutated_individual)

                # Decoding binary string, παίρνουμε το x, y και z του ατόμου όπως προέκυψαν μετά τη μετάλλαξη
                a, b, c = split_binary(temp, decimals)

                # Έλεγχος για μη νόμιμες τιμές
                # Αν το x μεγαλύτερο του 10, του δίνουμε την πλησιέστερη νόμιμη τιμή
                if a > 10.0:
                    # Επαναφέρουμε το ψηφίο που μεταλλάχθηκε και προκάλεσε τη μη νόμιμη τιμή
                    mutated_individual[j] = original_gene
                    if decimals == 0:  # 15 bits Δυαδική αναπαράσταση ακέραιου
                        mutated_individual[:5] = ['0', '1', '0', '1', '0']
                        # Το string αποτελείται απο τρία 5ψήφια string. Το 1ο αναπαριστά το x
                        # Δίνουμε την τιμή 10 ή 01010 στα πρώτα 5 ψηφία που είναι το ακέραιο
                    if decimals == 1:  # 27bits - 9-9-9 Δυαδική Αναπαράσταση με ακρίβεια ενός δεκαδικού
                        # Το string αποτελείται απο τρία 9ψήφια string. Το 1ο αναπαριστά το x
                        # Δίνουμε την τιμή 10.0 ή 01010 στα πρώτα 5 ψηφία που είναι το ακέραιο
                        # Τα υπόλοιπα ψηφία είναι το δεκαδικό μέρος 0000
                        mutated_individual[:9] = ['0', '1', '0', '1', '0', '0', '0', '0', '0']
                    if decimals == 2:  # 36bits - 12-12-12 (string me 3 12ψήφια, το πρώτο το χ --> δίνουμε τιμή 10.00)
                        mutated_individual[:12] = ['0', '1', '0', '1', '0', '0', '0', '0', '0', '0', '0', '0']
                    if decimals == 3:  # 45bits - 15-15-15 (string με 3 15ψήφια, δίνουμε στο χ τιμή 10.000)
                        mutated_individual[:15] = ['0', '1', '0', '1', '0', '0', '0', '0', '0', '0', '0', '0', '0',
                                                   '0', '0']
                    if decimals == 4:  # 57bits - 19-19-19 (string με 3 19ψήφια, δίνουμε στο χ τιμή 10.0000)
                        mutated_individual[:19] = ['0', '1', '0', '1', '0', '0', '0', '0', '0', '0', '0', '0', '0',
                                                   '0', '0', '0', '0', '0', '0']

                # Αν το y είναι μεγαλύτερο του 20, δίνουμε την πιο κοντινή νόμιμη, το 20
                # Τα πρώτα 5 ψηφία είναι το ακέραιο μέρος, τα υπόλοιπα αναλόγως της ακρίβειας δεκαδικών, το δεκαδικό
                if b > 20.0:
                    mutated_individual[j] = original_gene
                    if decimals == 0:  # 15bits - 5-5-5 --> Το 2o 5ψήφιο είναι το y -->δίνουμε νόμιμη τιμή 20
                        mutated_individual[5:10] = ['1', '0', '1', '0', '0']
                    if decimals == 1:  # 27bits - 9-9-9 --> Το 2o 9ψήφιο είναι το y -->δίνουμε νόμιμη τιμή 20.0
                        mutated_individual[9:18] = ['1', '0', '1', '0', '0', '0', '0', '0', '0']
                    if decimals == 2:  # 36bits - 12-12-12 -> Το 2o 12ψήφιο είναι το y -->δίνουμε νόμιμη τιμή 20.00
                        mutated_individual[12:24] = ['1', '0', '1', '0', '0', '0', '0', '0', '0', '0', '0', '0']
                    if decimals == 3:  # 45bits - 15-15-15 -> Το 2o 15ψήφιο είναι το y -->δίνουμε νόμιμη τιμή 20.000
                        mutated_individual[15:30] = ['1', '0', '1', '0', '0', '0', '0', '0', '0', '0', '0', '0',
                                                     '0', '0', '0']
                    if decimals == 4:  # 57bits - 19-19-19 -> Το 2o 19ψήφιο είναι το y -->δίνουμε νόμιμη τιμή 20.0000
                        mutated_individual[19:38] = ['1', '0', '1', '0', '0', '0', '0', '0', '0', '0', '0', '0',
                                                     '0', '0', '0', '0', '0', '0', '0']

                # Αν το z είναι μεγαλύτερο του 30, δίνουμε την πιο κοντινή νόμιμη, το 30
                # Τα πρώτα 5 ψηφία είναι το ακέραιο μέρος, τα υπόλοιπα αναλόγως της ακρίβειας δεκαδικών, το δεκαδικό
                if c > 30.0:
                    mutated_individual[j] = original_gene
                    if decimals == 0:  # 15bits - 5-5-5 -> Το 3o 5ψήφιο είναι το z -->δίνουμε νόμιμη τιμή 30
                        mutated_individual[10:] = ['1', '1', '1', '1', '0']
                    if decimals == 1:  # 27bits - 9-9-9 -> Το 3o 9ψήφιο είναι το z -->δίνουμε νόμιμη τιμή 30.0
                        mutated_individual[18:] = ['1', '1', '1', '1', '0', '0', '0', '0', '0']
                    if decimals == 2:  # 36bits - 12-12-12 -> Το 3o 12ψήφιο είναι το z -->δίνουμε νόμιμη τιμή 30.00
                        mutated_individual[24:] = ['1', '1', '1', '1', '0', '0', '0', '0', '0', '0', '0', '0']
                    if decimals == 3:  # 45bits - 15-15-15 ->Το 3o 15ψήφιο είναι το z -->δίνουμε νόμιμη τιμή 30.000
                        mutated_individual[30:] = ['1', '1', '1', '1', '0', '0', '0', '0', '0', '0', '0', '0', '0',
                                                   '0', '0']
                    if decimals == 4:  # 57bits - 19-19-19 -> Το 3o 19ψήφιο είναι το z -->δίνουμε νόμιμη τιμή 30.0000
                        mutated_individual[38:] = ['1', '1', '1', '1', '0', '0', '0', '0', '0', '0', '0', '0', '0',
                                                   '0', '0', '0', '0', '0', '0']

        mutated_population.append(''.join(mutated_individual))  # Μετατρέπουμε πάλι σε string και προσθέτουμε το άτομο
        # στην updated λίστα με τα μεταλλαγμένα άτομα, σε αυτή την λίστα θα περάσουν και τα άτομα που δεν υπέστησαν
        # μετάλλαξη, αυτούσια ώστε να περιλαμβάνει όλον τον πληθυσμό και τα μεταλλαγμένα άτομα

    return mutated_population  # Επιστέφουμε τη λίστα με τον πληθυσμό που περιλαμβάνει και τα μεταλλαγμένα άτομα
