import random
from Binary_Functions import decimal_to_binary, split_binary

"""1. ΣΥΝΑΡΤΗΣΗ ΑΡΧΙΚΟΠΟΙΗΣΗΣ -δέχεται ως ορίσματα το μέγεθος πληθυσμού, τον τύπο μεταβλητών, και τον αριθμό 
δεκαδικών -κάνει κλήση στην συνάρτηση decimal_to_binary (αρχείο Binary_Functions) για τη μετατροπή δεκαδικών σε 
δυαδικά -επιστρέφει μια λίστα με τον πληθυσμό -στην περίπτωση πραγματικής(3) και ακέραιας(2) αναπαράστασης: Η λίστα 
αποτελείται από εσωτερικές λίστες, κάθε εσωτερική λίστα είναι ένα άτομο και αποτελείται από 3 συμβολοσειρές των τιμών 
των μεταβητών x,y,z -στην περίπτωση των δυαδικών(1): Η λίστα αποτελείται από ενιαία δυαδική συμβολοσειρά που 
αναπαριστά τις τιμές των 3 μεταβλητών

"""


def initialize_population(size, variable, decimals):
    population_generated = []  # Δημιουργία λίστας πληθυσμού

    for _ in range(size):  # Επανάληψη για όσα άτομα δίνει ο χρήστης
        individual = []  # Αρχικοποίηση λίστας για κάθε άτομο (κάθε άτομο θα έχει 3 μεταβλητές: x, y, z)

        if variable == 1:  # Δυαδική αναπαράσταση πραγματικού αριθμού, κάθε άτομο-->ενιαία συμβολοσειρά

            # παραγωγή τυχαίου x εντός ορίων με όσα δεκαδικά όρισε ο χρήστης
            x_r = round(random.uniform(0, 10), decimals)
            x = decimal_to_binary(x_r, decimals)  # μετατροπή σε δυαδικό με όσα δεκαδικά όρισε ο χρήστης

            # ομοίως, για y
            y_r = round(random.uniform(0, 20), decimals)
            y = decimal_to_binary(y_r, decimals)

            # ομοίως, για z
            z_r = round(random.uniform(0, 30), decimals)
            z = decimal_to_binary(z_r, decimals)

            # Αφαιρούμε τις τελείες από τους δυαδικούς αριθμούς
            x_s = x.replace(".", "")
            y_s = y.replace(".", "")
            z_s = z.replace(".", "")

            # Ενώνουμε τους τρεις δυαδικούς αριθμούς σε έναν ενιαίο δυαδικό αριθμό
            individual = x_s + y_s + z_s

        elif variable == 2:  # Ακέραια αναπαράσταση
            x = str(random.randint(0, 10))  # Δημιουργία τυχαίου x εντός ορίων
            y = str(random.randint(0, 20))  # ομοίως, για y
            z = str(random.randint(0, 30))  # ομοίως, για z
            individual = [x, y, z]  # Δημιουργία εσωτερικής λίστας, κάθε λίστα --> 1 άτομο του πληθυσμού

        elif variable == 3:  # Δεκαδική αναπαράσταση
            x = str(round(random.uniform(0, 10), decimals))  # Τυχαίο x εντός ορίων, με αντίστοιχα δεκαδικά
            y = str(round(random.uniform(0, 20), decimals))  # ομοίως, για y
            z = str(round(random.uniform(0, 30), decimals))  # ομοίως, για z
            individual = [x, y, z]  # Δημιουργία εσωτερικής λίστας, κάθε λίστα --> 1 άτομο του πληθυσμού

        # Προσάρτηση κάθε νέου ατόμου (λίστα με 3 μεταβλητές) στη λίστα πληθυσμού
        population_generated.append(individual)

    return population_generated  # επιστροφή λίστας τυχαίου πληθυσμού
    # Σε δυαδική αναπαράσταση--> λίστα με ενιαίο binary string
    # Σε πραγματική & ακέραια--> λίστα με λίστες, κάθε υπολίστα αποτελείται από 3 συμβολοσειρές των τιμών των x,y και z


"""
2. ΒΟΗΘΗΤΙΚΗ ΣΥΝΑΡΤΗΣΗ της συνάρτησης calculate_fitness_scores
-δέχεται σαν ορίσματα τα x,y,z ενός ατόμου
-υπολογίζει το fitness score
-επιστρέφει το fitness score που είναι η συνάρηση f(x, y, z) = x**2 + y**3 + z**4 + x ∙ y ∙ z

"""


def fitness(x, y, z):
    score_individual = x ** 2 + y ** 3 + z ** 4 + x * y * z
    return score_individual


"""
3. ΣΥΝΑΡΤΗΣΗ ΥΠΟΛΟΓΙΣΜΟΥ calculate_fitness_scores
-δέχεται σαν ορίσματα, τον πληθυσμό της εκάστοτε γενιάς, τον τύπο μεταβλητής, τον αριθμό δεκαδικών
-Υπολογίζει με κλήση της συνάρτησης fitness επαναληπτικά για κάθε άτομο το fitness score και επιστρέφει μια λίστα με 
  τα fitness scores όλων των ατόμων
-Περίπτωση Δυαδικής αναπαράστασης:
 κάνει κλήση της συνάρτησης split binary, όπου γίνεται decoding του binary string στους 3 πραγματικούς αριθμούς
 που το απαρτίζουν και επαναληπτικό πέρασμα στην συνάρτηση fitness για υπολογισμό του fitness κάθε ατόμου
-Περίπτωση Ακέραιας - Πραγματικής:
 Περνάμε με type casting (decoding) τα 3 string της κάθε υπολίστας επαναληπτικά για κάθε άτομο στη βοηθητική συνάρτηση 
 fitness για να πάρουμε το fitness score κάθε ατόμου
Προσθέτουμε το fitness του κάθε ατόμου στη λίστα που θα επιστρέψουμε
Επίσης επιστρέφουμε το sum των fitness scores για υπολογισμό στην απόδοση κάθε ατόμου στην εξαναγκασμένη ρουλέτα
"""


def calculate_fitness_scores(population, variable_type, decimals):
    fitness_scores = []  # Δημιουργία λίστας για τα fitness scores

    for individual in population:  # Διαπέρασα για κάθε άτομο στον πληθυσμό
        # ΔΥΑΔΙΚΗ ΑΝΑΠΑΡΑΣΤΑΣΗ:
        if variable_type == 1:
            # Μετατροπή από δυαδική σε δεκαδική αναπαράσταση με κλήση της αντίστοιχης συνάρτησης
            x, y, z = split_binary(individual, decimals)
        # ΑΚΕΡΑΙΑ ΑΝΑΠΑΡΑΣΤΑΣΗ
        elif variable_type == 2:
            x, y, z = int(individual[0]), int(individual[1]), int(
                individual[2])  # Μετατροπή από συμβολοσειρά σε ακέραιο
        # ΠΡΑΓΜΑΤΙΚΗ ΑΝΑΠΑΡΑΣΤΑΣΗ
        elif variable_type == 3:
            x, y, z = float(individual[0]), float(individual[1]), float(
                individual[2])  # Μετατροπή από συμβολοσειρά σε αριθμό

        score = fitness(x, y, z)  # Υπολογισμός του fitness score του ατόμου με πέρασμα των 3 μεταβλητών κάθε ατόμου
        fitness_scores.append(score)  # Προσθήκη του score στη λίστα fitness scores
    synolo = sum(fitness_scores)  # Υπολογισμός συνόλου

    return fitness_scores, synolo  # Επιστροφή της λίστας fitness scores και αθροίσματος τους


"""4. ΣΥΝΑΡΤΗΣΗ ΕΠΙΛΟΓΗΣ ΕΞΑΝΑΓΚΑΣΜΕΝΗΣ ΡΟΥΛΕΤΑΣ -ROULETTE SELECTION -δέχεται σαν ορίσματα, λίστα με τα fitness scor, 
το άθροισμα των fitness score, τον πληθυσμό, τη λίστα με όλα τα άτομα) -Κάθε άτομο βάση του score του παίρνει ένα 
ποσοστό απόδοσης στη ρουλέτα (score/sumscore) ->σχετική απόδοση ή πιθανότητα επιλογής. Στη συνέχεια από τις 
πιθανότητα επιλογής προκύπτουν οι συσσωρευμένες πιθανότητες, προσθέτοντας διαδοχικά τις πιθανότητες κάθε ατόμου ώστε 
να φτάσουμε στο 1. Γυρίζουμε τη ρουλέτα (ένα random αριθμό από το 0 - 1 ) και σε όποιο διάστημα αθροιστικής 
πιθανότητας πέσει ο τυχαίο αριθμός, επιλέγεται το αντίστοιχο άτομο. -Φροντίζουμε να επιστρέψουμε μια λίστα με τα 
άτομα που επιλέχθηκαν από την εξαναγκασμένη ρουλέτα και μία λίστα με τα index τους στη λίστα πληθυσμού"""


def selection(score, sumscore, population_input, pop):  # ορίσματα συνάρτησης
    relative_probabilities = []  # λίστα με σχετική πιθανότητα κάθε ατόμου (fitness score/Sum scores)
    cumulative_probabilities = []  # Λίστα με συσσωρευμένες πιθανότητες για το γύρισμα της ρουλέτας
    roulette_chosens = []  # λίστα με τα επιλεγμένα άτομα που θα επιστρέψει η συνάρτηση

    # Υπολογισμός σχετικών πιθανοτήτων
    for s in score:  # διαπέραση της λίστας με τα fitness score
        relative_probability = s / sumscore  # Υπολογισμός για κάθε άτομο της σχετικής πιθανότητας (απόδοση στη ρουλέτα)
        relative_probabilities.append(relative_probability)  # Προσάρτηση στη λίστα με τις σχετικές πιθανότητες

    # Υπολογισμός συσσωρευτικών πιθανοτήτων
    cumulative_probability = 0  # αρχικοποίηση συσσωρευτικών πιθανοτήτων
    for rf in relative_probabilities:  # διαπέραση της λίστας των σχετικών πιθανοτήτων
        cumulative_probability += rf  #
        cumulative_probabilities.append(cumulative_probability)

    # Επιλογή ατόμων με τη μέθοδο της ρουλέτας
    for _ in range(population_input):  # Εξωτερική επαναληπτική δομή που θα επαναληφθεί τόσες φορές όσο και ο πληθυσμός
        random_num = random.random()  # Γύρισμα ρουλέτας
        for i, cp in enumerate(cumulative_probabilities):  # Εσωτερική επαναληπτική δομή ώστε ο τυχαίος αριθμός
            # αντιστοιχηθεί στο αντίστοιχο πεδίο συσσωρευτικής πιθανότητας που αντιστοιχεί στο άτομο [i] index
            if random_num <= cp:
                chosen = pop[i]  # αφού διαπεράσει όλες τις συσσωρευτικές πιθανότητες θα παραμείνει
                # στο κατάλληλο διάστημα συσσωρευτικής ικανότητας που αντιστοιχεί στο ίδιο  indexing με το άτομο
                # που θα είναι και το chosen που θα προσαρτήσουμε στη λίστα που επιστρέφουμε.
                # σκοπός είναι να γυρίσουμε τη ρουλέτα όσες και ο πληθυσμός για να πάρουμε τον ίδιο αριθμό ατόμων
                # για άτομα με καλύτερο fitness score μπορεί να πάρουμε παραπάνω του ενός αντιγράφου
                break  # Έξοδος από την επανάληψη όταν επιλεγεί ένα άτομο
        roulette_chosens.append(chosen)  # προσθήκη του ατόμου στη λίστα

    return roulette_chosens  # επιστροφή της λίστας των ατόμων που επιλέχθηκαν από την εξαναγκασμένη ρουλέτα


"""4. ΣΥΝΑΡΤΗΣΗ ΑΝΑΠΑΡΑΓΩΓΗΣ ΜΕΡΟΣ Α -->ΕΠΙΛΟΓΗ ΖΕΥΓΑΡΙΩΝ ΓΟΝΕΩΝ Παίρνει να όρισμα τον πληθυσμό (των ατόμων που έχουν 
επιλεγεί από τη διαδικασία επιλογής) και την πιθανότητα διασταύρωσης Για κάθε άτομο στον πληθυσμό επιλέγουμε έναν 
τυχαίο αριθμό r από 0 ως 1. Χρησιμοποιούμε την πιθανότητα διασταύρωσης που μας έδωσε ο χρήστης και αν r < πιθανότητα 
διασταύρωσης, επιλέγουμε το τρέχαν άτομο για διασταύρωση. Στη συνέχεια αν ο αριθμός των ατόμων που επιλέχθηκαν για 
διασταύρωση είναι μονός, προσθέτουμε ένα ακόμα άτομο"""


def select_parent_pairs(population, crossover_probability):
    parent_pairs = []  # Λίστα που θα αποθηκεύσουμε τα άτομα που θα μπουν για αναπαραγωγή
    reproduced_individuals_indices = []  # Λίστα που αποθηκεύουμε το index των ατόμων που αναπαράχθηκαν
    # ώστε να τα αντικαταστήσουμε με αναπαραχθέντα παιδιά

    for i, parent in enumerate(population):  # διαπέραση και απαρίθμηση του πληθυσμού επιλεγμένων ατόμων
        r = random.random()  # παραγωγή τυχαίου αριθμού (0-1)

        if r < crossover_probability:  # Αν ο παραχθέντας αριθμός είναι μικρότερος από pm το άτομο θα αναπαραχθεί
            parent_pairs.append(parent)  # Προσάρτηση του ατόμου στη λίστα

            reproduced_individuals_indices.append(i)  # Αποθηκεύουμε το index του γονέα που θα αναπαραχθεί ώστε
            # σε επόμενο βήμα, να τον εντοπίσουμε και αντικαταστήσουμε με ενα παιδί

    # Αν ο αριθμός των γονέων είναι μονός αριθμός, προσθέτουμε έναν ακόμη για να γίνει ζυγός
    if len(parent_pairs) % 2 != 0:
        r = random.randint(0, len(population) - 1)  # επιλέγουμε τυχαία ένα άτομο από τον πληθυσμό (ένα index)
        parent = population[r]  # Βρίσκουμε μέσα από τη λίστα το άτομο με το επιλεγμένο index
        parent_pairs.append(parent)  # To προσθέτουμε στη λίστα με του γονείς
        reproduced_individuals_indices.append(r)  # Προσθέτουμε και στην αντίστοιχη λίστα το index του

    # διατρέχουμε τη λίστα parent_pairs και δημιουργούμε μια λίστα με υπολίστες, κάθε υπολίστα
    # περιέχει ένα ζευγάρι γονέών που παρακάτω θα μπουν για αναπαραγωγή στη συνάρτηση crossover
    paired_parents = [parent_pairs[i:i + 2] for i in range(0, len(parent_pairs), 2)]

    return paired_parents, reproduced_individuals_indices
    # επιστρέφουμε τα λίστα με ζευγάρια γονέων, και λίστα
    # με τα index των γονιών που θα αναπαραχθούν


"""
5. ΣΥΝΑΡΤΗΣΗ ΑΝΑΠΑΡΑΓΩΓΗΣ ΜΕΡΟΣ Β ΓΙΑ ΔΕΚΑΔΙΚΟ ΣΥΣΤΗΜΑ  -->ΑΝΑΠΑΡΑΓΩΓΗ ΖΕΥΓΑΡΙΩΝ ΚΑΙ ΔΗΜΙΟΥΡΓΙΑ ΠΑΙΔΙΩΝ
Για ακέραια(2) και πραγματική αναπαράσταση(3).
Παίρνει να όρισμα 2 γονείς και τους διασταυρώνει επιστρέφοντας τα 2 παιδιά που προέκυψαν
Επειδή κάθε άτομο αποτελείται από 3 αριθμούς επιλέχθηκε το σημείο 1 ώς σημείο διασταύρωσης
Εδώ δεν χρειάστηκε να εφαρμόσουμε έλεγχο αν βγούμε εκτός ορίων, καθώς οι θέσεις που γίνονται
ανταλλαγές είναι αντίστοιχες οπότε είναι εντός των ίδιων ορίων.
"""


def crossover_dec(parent1, parent2):
    crossover_point = 1
    child1 = parent1[:crossover_point] + parent2[crossover_point:]
    child2 = parent2[:crossover_point] + parent1[crossover_point:]
    return child1, child2


"""
6. ΣΥΝΑΡΤΗΣΗ ΑΝΑΠΑΡΑΓΩΓΗΣ ΜΕΡΟΣ Β  ΓΙΑ ΔΥΑΔΙΚΟ ΣΥΣΤΗΜΑ-->ΑΝΑΠΑΡΑΓΩΓΗ ΖΕΥΓΑΡΙΩΝ ΚΑΙ ΔΗΜΙΟΥΡΓΙΑ ΠΑΙΔΙΩΝ
ΓΙΑ ΔΥΑΔΙΚΟ ΣΥΣΤΗΜΑ -> Δυαδική αναπαράσταση (2)
Παίρνει να όρισμα 2 γονείς, και τον αριθμό δεκαδικών, διασταυρώνει τους γονείς και 
επιστρέφει τα 2 παιδιά που προέκυψαν
Επειδή οι γονείς εδώ αναπαρίστανται από 1 ενιαία δυαδικό sting, εφαρμόουμε επιπλέον έλεγχο 
για παράνομες τιμές. 
Γίνεται έλεγχος σε κάθε παραγόμενο παιδί, και αν έχει προκύψει μη νόμιμη τιμή μεταβλητής, αντικαθίσταται 
από την πιο κοντινή νόμιμη της.


"""


def crossover_bin(parent1, parent2, decimals):
    if decimals == 0:
        crossover_point = 10
    elif decimals == 1:
        crossover_point = 19  # 27bit #για αναπαράσταση με 1 δεκαδικό, έχουμε μήκος 27 οπότε επιλέγουμε ενα σημείο <27
    elif decimals == 2:
        crossover_point = 30  # 36bit  #ομοίως <36
    elif decimals == 3:
        crossover_point = 39  # 45bit  #ομοίως <45
    elif decimals == 4:
        crossover_point = 45  # 57bit  #ομοίως <57

    # δημιουργούμε το πρώτο παιδί μετατρέποντας σε λίστα τα ψηφία για να γίνει η διασταύρωση
    # και αν βγει εκτός ορίων να περάσουμε στο κατάλληλο σημείο την νόμιμη τιμή
    child1 = list(parent1)[:crossover_point] + list(parent2)[crossover_point:]

    # Για να κάνουμε decoding και να ελέγχουμε τις παραγόμενες τιμές, παράγουμε το ίδιο παιδί σε μορφή string
    child1_l = parent1[:crossover_point] + parent2[crossover_point:]  # Δημιουργία πρώτου παιδιού
    a, b, c = split_binary(child1_l, decimals)  # κλήση σε συνάρτηση για να πάρουμε τους αριθμούς που απαρτίζουν το
    # παιδί

    # Ελέγχουμε τις τρεις μεταβλητές που έχουν προκύψει για κάθε παιδί αν είναι εντός ορίων
    # Ελέγχουμε μόνο για τα άνω όρια, αφού βάση της κωδικοποίησης μας δε γίνεται να πάρουμε αριθμούς
    # μικρότερους από το 0 => κάθε δυαδικό 5 ψηφία (ακέραιο μέρος από 0000-11111 (0-31)
    # + υπόλοιπα ψηφία δεκαδικό αναλόγως του πλήθους δεκαδικών

    # Αν το χ είναι μεγαλύτερο του 10 αντικαθιστούμε με την πιο κοντινή νόμιμη-> το 10 ή το δυαδικό 01010
    if a > 10.0:
        # τα πρώτα 5 ψηφία του δυαδικού είναι το ακέραιο μέρος και τα υπόλοιπα (αναλόγως του πλήθους των δεκαδικών)
        # το δεκαδικό
        # Για 0 δεκαδικά, έχουμε τρία 5-ψήφια δυαδικά, το πρώτο είναι το x, αντικαθιστούμε με 10
        if decimals == 0:  # 15bits 5-5-5
            child1[:5] = ['0', '1', '0', '1', '0']
        if decimals == 1:  # 27bits - 9-9-9
            # Για ενα δεκαδικό, έχουμε τρία 9-ψήφια δυαδικά, το πρώτο είναι το x, αντικαθιστούμε με 10.0
            child1[:9] = ['0', '1', '0', '1', '0', '0', '0', '0', '0']
        if decimals == 2:  # 36bits - 12-12-12
            # Για 2 δεκαδικά, έχουμε τρία 12-ψήφια δυαδικά, το πρώτο είναι το x, αντικαθιστούμε με 10.00
            child1[:12] = ['0', '1', '0', '1', '0', '0', '0', '0', '0', '0', '0', '0']
        if decimals == 3:  # 45bits - 15-15-15
            # Για 3 δεκαδικά, έχουμε τρία 15-ψήφια δυαδικά, το πρώτο είναι το x, αντικαθιστούμε με 10.000
            child1[:15] = ['0', '1', '0', '1', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
        if decimals == 4:  # 57bits - 19-19-19
            # Για 4 δεκαδικά, έχουμε τρία 19-ψήφια δυαδικά, το πρώτο είναι το x, αντικαθιστούμε με 10.0000
            child1[:19] = ['0', '1', '0', '1', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',
                           '0', '0', '0', '0']

    # Αν το y είναι μεγαλύτερο του 20 αντικαθιστούμε με την πιο κοντινή νόμιμη-> το 20 ή το δυαδικό 10100
    if b > 20.0:
        if decimals == 0:  # 15bits - 5-5-5
            # Για 0 δεκαδικά, έχουμε τρία 5-ψήφια δυαδικά, το δεύτερο είναι το y, αντικαθιστούμε με 20
            child1[5:10] = ['1', '0', '1', '0', '0']
        if decimals == 1:  # 27bits - 9-9-9
            # Για ενα δεκαδικό, έχουμε τρία 9-ψήφια δυαδικά, το δεύτερο είναι το y, αντικαθιστούμε με 20.0
            child1[9:18] = ['1', '0', '1', '0', '0', '0', '0', '0', '0']
        if decimals == 2:  # 36bits - 12-12-12
            # Για 2 δεκαδικά, έχουμε τρία 12-ψήφια δυαδικά, το δεύτερο είναι το y, αντικαθιστούμε με 20.00
            child1[12:24] = ['1', '0', '1', '0', '0', '0', '0', '0', '0', '0', '0', '0']
        if decimals == 3:  # 45bits - 15-15-15
            # Για 3 δεκαδικά, έχουμε τρία 15-ψήφια δυαδικά, το δεύτερο είναι το y, αντικαθιστούμε με 20.000
            child1[15:30] = ['1', '0', '1', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
        if decimals == 4:  # 57bits - 19-19-19
            # Για 4 δεκαδικά, έχουμε τρία 19-ψήφια δυαδικά, το δεύτερο είναι το y, αντικαθιστούμε με 20.0000
            child1[19:38] = ['1', '0', '1', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',
                             '0', '0', '0', '0']

    # Αν το z είναι μεγαλύτερο του 30 αντικαθιστούμε με την πιο κοντινή νόμιμη-> το 30 ή το δυαδικό 11110
    if c > 30.0:
        if decimals == 0:  # 15bits - 5-5-5
            # Για 0 δεκαδικά, έχουμε τρία 5-ψήφια δυαδικά, το τρίτο είναι το z, αντικαθιστούμε με 30
            child1[10:] = ['1', '1', '1', '1', '0']
        if decimals == 1:  # 27bits - 9-9-9
            # Για ενα δεκαδικό, έχουμε τρία 9-ψήφια δυαδικά, το τρίτο είναι το z, αντικαθιστούμε με 30.0
            child1[18:] = ['1', '1', '1', '1', '0', '0', '0', '0', '0']
        if decimals == 2:  # 36bits - 12-12-12
            # Για 2 δεκαδικά, έχουμε τρία 12-ψήφια δυαδικά, το τρίτο είναι το z, αντικαθιστούμε με 30.00
            child1[24:] = ['1', '1', '1', '1', '0', '0', '0', '0', '0', '0', '0', '0']
        if decimals == 3:  # 45bits - 15-15-15
            # Για 3 δεκαδικά, έχουμε τρία 15-ψήφια δυαδικά, το τρίτο είναι το z, αντικαθιστούμε με 30.000
            child1[30:] = ['1', '1', '1', '1', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
        if decimals == 4:  # 57bits - 19-19-19
            # Για 4 δεκαδικά, έχουμε τρία 19-ψήφια δυαδικά, το τρίτο είναι το z, αντικαθιστούμε με 30.0000
            child1[38:] = ['1', '1', '1', '1', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',
                           '0']
    # Ίδια διαδικασία για το παιδί 2
    # δημιουργούμε το δεύτερο παιδί μετατρέποντας σε λίστα τα ψηφία για να γίνει η διασταύρωση
    # και αν βγει εκτός ορίων να περάσουμε στο κατάλληλο σημείο τη νόμιμη τιμή
    child2 = list(parent2)[:crossover_point] + list(parent1)[crossover_point:]
    child2_l = parent2[:crossover_point] + parent1[crossover_point:]

    a, b, c = split_binary(child2_l, decimals)  # decoding

    # Ίδια διαδικασία ελέγχου για μη νόμιμες τιμές, με μόνη αλλαγή το όνομα λίστας παιδιού child2
    if a > 10.0:
        if decimals == 0:  # 15 bits 5-5-5
            child2[:5] = ['0', '1', '0', '1', '0']
        if decimals == 1:  # 27bits - 9-9-9
            child2[:9] = ['0', '1', '0', '1', '0', '0', '0', '0', '0']
        if decimals == 2:  # 36bits - 12-12-12
            child2[:12] = ['0', '1', '0', '1', '0', '0', '0', '0', '0', '0', '0', '0']
        if decimals == 3:  # 45bits - 15-15-15
            child2[:15] = ['0', '1', '0', '1', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
        if decimals == 4:  # 57bits - 19-19-19
            child2[:19] = ['0', '1', '0', '1', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',
                           '0', '0', '0', '0']

    if b > 20.0:
        if decimals == 0:  # 15bits - 5-5-5
            child2[5:10] = ['1', '0', '1', '0', '0']
        if decimals == 1:  # 27bits - 9-9-9
            child2[9:18] = ['1', '0', '1', '0', '0', '0', '0', '0', '0']
        if decimals == 2:  # 36bits - 12-12-12
            child2[12:24] = ['1', '0', '1', '0', '0', '0', '0', '0', '0', '0', '0', '0']
        if decimals == 3:  # 45bits - 15-15-15
            child2[15:30] = ['1', '0', '1', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
        if decimals == 4:  # 57bits - 19-19-19
            child2[19:38] = ['1', '0', '1', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',
                             '0', '0', '0', '0']

    if c > 30.0:
        if decimals == 0:  # 15bits 5-5-5
            child2[10:] = ['1', '1', '1', '1', '0']
        if decimals == 1:  # 27bits - 9-9-9
            child2[18:] = ['1', '1', '1', '1', '0', '0', '0', '0', '0']
        if decimals == 2:  # 36bits - 12-12-12
            child2[24:] = ['1', '1', '1', '1', '0', '0', '0', '0', '0', '0', '0', '0']
        if decimals == 3:  # 45bits - 15-15-15
            child2[30:] = ['1', '1', '1', '1', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
        if decimals == 4:  # 57bits - 19-19-19
            child2[38:] = ['1', '1', '1', '1', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',
                           '0']

    # επιστρέφουμε τα δύο παιδιά που προέκυψαν αφού τα μετατρέψουμε πάλι σε strings
    return ''.join(child1), ''.join(child2)
